"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[1513],{581(e,n,s){s.r(n),s.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>d,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"concepts/mental-model","title":"The Mental Model","description":"Understanding the Weave Loop","source":"@site/docs/concepts/mental-model.md","sourceDirName":"concepts","slug":"/concepts/mental-model","permalink":"/loom/concepts/mental-model","draft":false,"unlisted":false,"editUrl":"https://github.com/leonieziechmann/loom/tree/main/docs/docs/concepts/mental-model.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Core Concepts","permalink":"/loom/concepts/"},"next":{"title":"Data Flow","permalink":"/loom/concepts/data-flow"}}');var i=s(4848),o=s(8453);const a={sidebar_position:1},l="The Mental Model",r={},c=[{value:"The Weave Loop",id:"the-weave-loop",level:2},{value:"The Lifecycle of a Motif",id:"the-lifecycle-of-a-motif",level:2},{value:"1. Scope (Setup)",id:"1-scope-setup",level:3},{value:"2. Measure (Logic)",id:"2-measure-logic",level:3},{value:"The Convergence Check (Optimization)",id:"the-convergence-check-optimization",level:3},{value:"3. Draw (Visuals)",id:"3-draw-visuals",level:3},{value:"Visualization: The &quot;V&quot; Shape",id:"visualization-the-v-shape",level:2},{value:"Convergence &amp; Stability",id:"convergence--stability",level:2},{value:"The <code>max-passes</code> Safety Valve",id:"the-max-passes-safety-valve",level:3},{value:"Handling Non-Convergence",id:"handling-non-convergence",level:3}];function h(e){const n={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"the-mental-model",children:"The Mental Model"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Understanding the Weave Loop"})}),"\n",(0,i.jsxs)(n.p,{children:["To use Loom effectively, you must unlearn one thing about Typst: ",(0,i.jsx)(n.strong,{children:"Linearity."})]}),"\n",(0,i.jsx)(n.p,{children:'In standard Typst, code executes from top to bottom. A function at the start of the document cannot know what happens at the end. This is why you can\'t easily print a "Total Page Count" on Page 1 without complex state hacks.'}),"\n",(0,i.jsxs)(n.p,{children:["Loom changes this by introducing ",(0,i.jsx)(n.strong,{children:"Time Travel"})," (or more technically, a multi-pass feedback loop)."]}),"\n",(0,i.jsx)(n.h2,{id:"the-weave-loop",children:"The Weave Loop"}),"\n",(0,i.jsxs)(n.p,{children:["Loom does not run your document once. It runs it in a loop, refining the data with each iteration until everything is stable. We call this the ",(0,i.jsx)(n.strong,{children:"Weave Loop"}),"."]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Pass 1 (Discovery):"})," Loom runs your code. Components emit signals (prices, page numbers, headings). Loom collects them but draws nothing."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Pass 2 (Reaction):"})," Loom runs your code again. This time, the signals from Pass 1 are injected into the global ",(0,i.jsx)(n.strong,{children:"Context"}),'. Components can now read data from the "future" (or rather, the previous pass).']}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Pass 3 (Stabilization):"})," If the reaction caused ",(0,i.jsx)(n.em,{children:"new"})," changes (e.g., the Table of Contents grew, pushing content to a new page), Loom runs again."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Final Pass (Drawing):"})," Once the data stops changing (Convergence), Loom executes the final ",(0,i.jsx)(n.code,{children:"draw"})," phase to produce the PDF."]}),"\n"]}),"\n",(0,i.jsx)(n.mermaid,{value:"%%{init: {'theme': 'base', 'themeVariables': { 'fontSize': '12px'}, 'flowchart': {'rankSpacing': 25, 'nodeSpacing': 15, 'curve': 'basis'}}}%%\nflowchart LR\n    Start([Start]) --\x3e Init[Init Context]\n    Init --\x3e MeasurePass\n\n    subgraph Loop [\"The Weave Loop\"]\n        direction TB\n        MeasurePass[/\"Measure Phase\"/] --\x3e Compare{Signals Changes?}\n\n        Compare -- Yes --\x3e CheckLimit{Max Passes?}\n\n        CheckLimit -- No --\x3e Inject[Inject Signals]\n        Inject --\x3e MeasurePass\n\n        CheckLimit -- Yes --\x3e DrawPass\n    end\n\n    Compare -- No --\x3e DrawPass[/\"Draw Phase\"/]\n\n    DrawPass --\x3e Render[Render Output]\n    Render --\x3e Stop([End])\n\n    style MeasurePass fill:#e1f5fe,stroke:#01579b\n    style DrawPass fill:#e8f5e9,stroke:#1b5e20\n    style Inject fill:#fff9c4,stroke:#fbc02d"}),"\n",(0,i.jsxs)(n.p,{children:["This happens automatically. The ",(0,i.jsx)(n.code,{children:"weave"})," function handles the complexity of the loop; you only need to define the logic for your components."]}),"\n",(0,i.jsx)(n.h2,{id:"the-lifecycle-of-a-motif",children:"The Lifecycle of a Motif"}),"\n",(0,i.jsxs)(n.p,{children:["When ",(0,i.jsx)(n.code,{children:"weave"})," processes a component (Motif), it guides it through specific stages. It is important to understand that ",(0,i.jsx)(n.strong,{children:"Children are processed IN BETWEEN these stages"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"1-scope-setup",children:"1. Scope (Setup)"}),"\n",(0,i.jsxs)(n.p,{children:["First, the ",(0,i.jsx)(n.code,{children:"scope"})," function is called."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Input:"})," The current Context (",(0,i.jsx)(n.code,{children:"ctx"}),") from the parent."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Action:"})," You can modify the context (e.g., set a variable, add a theme)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Output:"})," A new Context."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Crucial Detail:"})," This ",(0,i.jsx)(n.em,{children:"new"})," context is what will be passed to your children."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"(The engine now pauses your component to calculate your Children and collect their signals using the scope you just provided.)"})}),"\n",(0,i.jsx)(n.h3,{id:"2-measure-logic",children:"2. Measure (Logic)"}),"\n",(0,i.jsxs)(n.p,{children:["Once the children are done, the engine calls your ",(0,i.jsx)(n.code,{children:"measure"})," function."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Input:"})," The Context (from step 1) AND the ",(0,i.jsx)(n.strong,{children:"Data collected from Children"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Action:"})," You perform your logic (e.g., summing up prices, filtering items)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Output:"})," You return a tuple ",(0,i.jsx)(n.code,{children:"(signal, view)"}),".","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"signal"})," (public): Data sent ",(0,i.jsx)(n.strong,{children:"UP"})," to your parent."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"view"})," (private): Data kept ",(0,i.jsx)(n.strong,{children:"LOCALLY"})," for your own drawing."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"the-convergence-check-optimization",children:"The Convergence Check (Optimization)"}),"\n",(0,i.jsx)(n.p,{children:"At this point, Loom checks if the data is stable."}),"\n",(0,i.jsx)(n.admonition,{title:"Smart Skipping",type:"info",children:(0,i.jsxs)(n.p,{children:["If the signals changed compared to the last pass, the engine ",(0,i.jsx)(n.strong,{children:"skips the Draw phase"}),". This saves performance by avoiding expensive layout calculations until the data has stabilized."]})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["If the signals changed compared to the last pass, the document has ",(0,i.jsx)(n.strong,{children:"not converged"}),"."]}),"\n",(0,i.jsx)(n.li,{children:"If the signals are stable (or this is the final pass), the engine proceeds to Draw."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"3-draw-visuals",children:"3. Draw (Visuals)"}),"\n",(0,i.jsxs)(n.p,{children:["Finally, if we are in the render pass, the ",(0,i.jsx)(n.code,{children:"draw"})," function is called."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Input:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ctx"}),": The Scope."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"signal"}),": The Signal you emitted."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"view"}),": The View data you calculated."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"body"}),": The ",(0,i.jsx)(n.strong,{children:"Rendered Content of your Children"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Action:"})," You wrap the children in a visual element (e.g., ",(0,i.jsx)(n.code,{children:"block"}),", ",(0,i.jsx)(n.code,{children:"table"}),", ",(0,i.jsx)(n.code,{children:"text"}),")."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Output:"})," A standard Typst content element."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"visualization-the-v-shape",children:'Visualization: The "V" Shape'}),"\n",(0,i.jsx)(n.p,{children:'You can visualize the execution flow of a single component as a "V" shape, collecting data on the way up.'}),"\n",(0,i.jsx)(n.admonition,{title:'The "V" Shape',type:"tip",children:(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Down (Scope):"})," You prepare the Context."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"...Children Execute..."})," (They use your Scope, run their own V-shapes, and return signals)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Up (Measure):"})," You receive their signals and calculate your own."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Out (Draw):"})," You wrap their finished content."]}),"\n"]})}),"\n",(0,i.jsx)("center",{children:(0,i.jsx)(n.mermaid,{value:"%%{init: {'theme': 'base', 'themeVariables': { 'fontSize': '13px'}, 'flowchart': {'rankSpacing': 40, 'nodeSpacing': 30, 'curve': 'basis'}}}%%\nflowchart TD\n    %% Styling\n    classDef phase fill:#f9f9f9,stroke:#333,stroke-width:2px;\n    classDef data fill:#e1f5fe,stroke:#0277bd,stroke-width:1px,stroke-dasharray: 5 5;\n\n    subgraph Component [\"Component Lifecycle\"]\n        direction TB\n        Step1[\"1. SCOPE (Down)\n\nPREPARE Context\"]:::phase\nStep3[\"3. MEASURE (Up)\nCALCULATE Logic\"]:::phase\nStep4[\"4. DRAW (Out)\nRENDER Content\"]:::phase\nend\n\n    Children(\"2. CHILDREN EXECUTE\n\n(Recursion)\"):::phase\n\n    %% Data Flow\n    Step1 --\x3e|\"Context (ctx)\"| Children\n    Children --\x3e|\"Signals (public)\"| Step3\n    Step3 --\x3e|\"View (private)\"| Step4\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This architecture ensures that by the time you reach the ",(0,i.jsx)(n.code,{children:"draw"})," function, you have ",(0,i.jsx)(n.strong,{children:"all"})," the information you need: context from above, and signals from below."]}),"\n",(0,i.jsx)(n.h2,{id:"convergence--stability",children:"Convergence & Stability"}),"\n",(0,i.jsxs)(n.p,{children:['Loom is a "Fixed-Point Engine." This means it repeats the loop until the document ',(0,i.jsx)(n.strong,{children:"Converges"})," (stops changing)."]}),"\n",(0,i.jsxs)(n.h3,{id:"the-max-passes-safety-valve",children:["The ",(0,i.jsx)(n.code,{children:"max-passes"})," Safety Valve"]}),"\n",(0,i.jsx)(n.p,{children:"To prevent infinite loops (e.g., A changes B, B changes A), Loom has a hard limit."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Default:"})," 2 passes (sufficient for 90% of documents)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Configurable:"})," You can increase this in ",(0,i.jsx)(n.code,{children:"weave(max-passes: 5)"})," if you have deep dependency chains."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"handling-non-convergence",children:"Handling Non-Convergence"}),"\n",(0,i.jsx)(n.p,{children:"Sometimes, complex logic might fail to settle within the allowed passes (e.g., an oscillating signal). Instead of failing silently or crashing, you can intercept this state."}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"weave"})," function accepts a ",(0,i.jsx)(n.code,{children:"handle-nonconvergence"})," callback. This allows you to log warnings, inspect the conflicting data, or even force a fallback state."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typ",children:"#show: weave.with(\n  max-passes: 5,\n  handle-nonconvergence: (ctx, iterations, last-payload, current-payload) => {\n    // Example: Warn the user if the document is unstable\n    panic(\"Document did not converge after \" + str(iterations) + \" passes.\")\n    // You can also inspect 'last-payload' vs 'current-payload' to see what changed.\n  }\n)\n"})})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453(e,n,s){s.d(n,{R:()=>a,x:()=>l});var t=s(6540);const i={},o=t.createContext(i);function a(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);