"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[691],{8453(e,n,t){t.d(n,{R:()=>s,x:()=>l});var a=t(6540);const i={},r=a.createContext(i);function s(e){const n=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(r.Provider,{value:n},e.children)}},8673(e,n,t){t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"concepts/pattern-aggregator","title":"Pattern: The Aggregator","description":"Collecting Data with Signals","source":"@site/docs/concepts/pattern-aggregator.md","sourceDirName":"concepts","slug":"/concepts/pattern-aggregator","permalink":"/loom/concepts/pattern-aggregator","draft":false,"unlisted":false,"editUrl":"https://github.com/leonieziechmann/loom/tree/main/docs/concepts/pattern-aggregator.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Pattern: The Provider","permalink":"/loom/concepts/pattern-provider"},"next":{"title":"Pattern: The Enforcer","permalink":"/loom/concepts/pattern-enforcer"}}');var i=t(4848),r=t(8453);const s={sidebar_position:5},l="Pattern: The Aggregator",o={},c=[{value:"The Problem: Separation of Data and View",id:"the-problem-separation-of-data-and-view",level:2},{value:"The Solution: Signals",id:"the-solution-signals",level:2},{value:"Scenario 1: The Visual List (Content Aggregation)",id:"scenario-1-the-visual-list-content-aggregation",level:3},{value:"Usage",id:"usage",level:4},{value:"Scenario 2: The Data Builder (Data Aggregation)",id:"scenario-2-the-data-builder-data-aggregation",level:3},{value:"Usage",id:"usage-1",level:4},{value:"Pro Tip: The Query Module",id:"pro-tip-the-query-module",level:2}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"pattern-the-aggregator",children:"Pattern: The Aggregator"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Collecting Data with Signals"})}),"\n",(0,i.jsxs)(n.p,{children:['In standard Typst, data usually flows one way: down. This makes it frustratingly difficult to build things like a "Total Price" at the top of an invoice, or a "Table of Contents" that reacts to dynamic content. You often have to define the data ',(0,i.jsx)(n.em,{children:"outside"}),' your content, separating the "source of truth" from the "display."']}),"\n",(0,i.jsxs)(n.p,{children:["Loom solves this with the ",(0,i.jsx)(n.strong,{children:"Aggregator Pattern"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"the-problem-separation-of-data-and-view",children:"The Problem: Separation of Data and View"}),"\n",(0,i.jsxs)(n.p,{children:["Imagine you are writing a receipt. In standard Typst, if you want a list of items ",(0,i.jsx)(n.em,{children:"and"})," a total sum, you cannot just write the items. You have to create a data structure first."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:'The Typst Way (The "Old" Way):'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typ",children:'// 1. Define Data separately\nlet items = (\n  (name: "Apple", price: 1.2),\n  (name: "Banana", price: 0.8),\n)\n\n// 2. Calculate Total separately\nlet total = items.map(i => i.price).sum()\n\n// 3. Render Loop\n#table(..items.map(i => [ #i.name: #i.price ]))\n#strong[Total: #total]\n'})}),"\n",(0,i.jsx)(n.p,{children:'This works for simple lists, but it breaks down when your document gets complex. What if "Apple" is inside a conditional? What if "Banana" is imported from another file? You lose the ability to write declarative markup.'}),"\n",(0,i.jsx)(n.h2,{id:"the-solution-signals",children:"The Solution: Signals"}),"\n",(0,i.jsxs)(n.p,{children:["In Loom, components can emit ",(0,i.jsx)(n.strong,{children:"Signals"})," (data packets) that bubble up to their parent. Because Loom runs the children's ",(0,i.jsx)(n.code,{children:"measure"})," phase ",(0,i.jsx)(n.em,{children:"before"})," the parent's ",(0,i.jsx)(n.code,{children:"measure"})," phase, the parent can aggregate this data and react to it immediately in the ",(0,i.jsx)(n.strong,{children:"same pass"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"This restores the declarative style. You write the items where they belong, and the parent figures out the total."}),"\n",(0,i.jsx)(n.h3,{id:"scenario-1-the-visual-list-content-aggregation",children:"Scenario 1: The Visual List (Content Aggregation)"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Goal:"})," The children should render themselves normally (like a list), and the parent just appends a summary line."]}),"\n",(0,i.jsxs)(n.p,{children:["We use ",(0,i.jsx)(n.code,{children:"content-motif"})," for the children because they have a visual presence."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typ",children:"// CHILD: Renders itself AND emits a signal\n#let item(name, price) = content-motif(\n  measure: (ctx, body) => (price: price), // Emit price signal\n  draw: (ctx, body) => {\n    block(width: 100%, inset: 2pt)[#name #h(1fr) #price]\n  }\n)\n\n// PARENT: Renders children THEN adds total\n#let receipt(body) = motif(\n  measure: (ctx, children-signals) => {\n    // 1. Aggregate immediately (Same-Pass)\n    let total = children-signals.map(s => s.price).sum()\n\n    // 2. Pass total to the View\n    ( (total: total), (total: total) )\n  },\n  draw: (ctx, public, view, body) => {\n    block(stroke: 1pt, inset: 1em)[\n      #align(center)[*Receipt*]\n      #line(length: 100%)\n      #body // Render the children normally\n      #line(length: 100%)\n      #align(right)[*Total: #view.total*]\n    ]\n  },\n  body\n)\n"})}),"\n",(0,i.jsx)(n.h4,{id:"usage",children:"Usage"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typ",children:'// USAGE: Declarative and clean\n#receipt[\n  #item("Apples", 1.50)\n  #item("Bananas", 2.00)\n]\n'})}),"\n",(0,i.jsx)(n.h3,{id:"scenario-2-the-data-builder-data-aggregation",children:"Scenario 2: The Data Builder (Data Aggregation)"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Goal:"})," The children should be ",(0,i.jsx)(n.strong,{children:"invisible"})," data points. The parent collects them and builds a completely new structure (like a Table or Chart)."]}),"\n",(0,i.jsxs)(n.p,{children:["We use ",(0,i.jsx)(n.code,{children:"data-motif"})," for the children. This is a shorthand that skips the ",(0,i.jsx)(n.code,{children:"draw"})," phase entirely, which is faster and cleaner."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typ",children:"// CHILD: Pure Data (No visual output)\n#let entry(name, price) = data-motif(\n  measure: (ctx) => (name: name, price: price)\n)\n\n// PARENT: Builds the view entirely from signals\n#let price-table(body) = motif(\n  measure: (ctx, children-signals) => {\n    // We pass the raw signals to the view to build the table\n    ( (count: children-signals.len()), children-signals )\n  },\n  draw: (ctx, public, signals, body) => {\n    // 'body' is ignored/empty because children are data-motifs!\n    table(\n      columns: 2,\n      [*Item*], [*Price*],\n      ..signals.map(s => (s.name, str(s.price))).flatten(),\n      [*Total*], [*#signals.map(s => s.price).sum()*]\n    )\n  },\n  body\n)\n\n"})}),"\n",(0,i.jsx)(n.h4,{id:"usage-1",children:"Usage"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typ",children:'// USAGE\n#price-table[\n  #entry("Server A", 500) // Invisible\n  #entry("Server B", 1200)\n]\n'})}),"\n",(0,i.jsx)(n.h2,{id:"pro-tip-the-query-module",children:"Pro Tip: The Query Module"}),"\n",(0,i.jsx)(n.p,{children:"When your aggregation logic gets complex (e.g., filtering specific items or searching deeply nested trees), manual array mapping can be tedious."}),"\n",(0,i.jsxs)(n.p,{children:["Loom provides the ",(0,i.jsx)(n.code,{children:"loom.query"})," module to make this easier. It works similarly to database queries for your document tree."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typ",children:'// Inside Parent measure(ctx, children-signals)\n\n// 1. Summing a specific field\nlet total = loom.query.sum-signals(children-signals, "price")\n\n// 2. Finding specific children\nlet apples = loom.query.where(children-signals, s => s.name == "Apple")\n\n// 3. Deep Collection (Recursive)\n// Useful if your items are nested inside other containers (like groups or divs)\nlet all-items = loom.query.collect(children-signals, "price")\n'})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);