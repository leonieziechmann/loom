"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[2206],{667(e,n,t){t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"concepts/pattern-provider","title":"Pattern: The Provider","description":"Solving Parameter Drilling with Scope","source":"@site/docs/concepts/pattern-provider.md","sourceDirName":"concepts","slug":"/concepts/pattern-provider","permalink":"/loom/concepts/pattern-provider","draft":false,"unlisted":false,"editUrl":"https://github.com/leonieziechmann/loom/tree/main/docs/concepts/pattern-provider.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"State Management & Mutators","permalink":"/loom/concepts/state-management"},"next":{"title":"Pattern: The Aggregator","permalink":"/loom/concepts/pattern-aggregator"}}');var s=t(4848),i=t(8453);const r={sidebar_position:4},l="Pattern: The Provider",a={},c=[{value:"The Problem: Brittle Templates",id:"the-problem-brittle-templates",level:2},{value:"The Solution: Context Injection",id:"the-solution-context-injection",level:2},{value:"Implementing a &quot;Smart&quot; Component",id:"implementing-a-smart-component",level:3},{value:"Using the Component",id:"using-the-component",level:3},{value:"Critical Concepts",id:"critical-concepts",level:2},{value:"1. Scope is &quot;Public&quot; (Self + Children)",id:"1-scope-is-public-self--children",level:3},{value:"2. Measure is &quot;Private&quot; (Local Only)",id:"2-measure-is-private-local-only",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Always Sanitize with Scope",id:"always-sanitize-with-scope",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"pattern-the-provider",children:"Pattern: The Provider"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Solving Parameter Drilling with Scope"})}),"\n",(0,s.jsxs)(n.p,{children:["One of the biggest challenges in building complex Typst templates is ",(0,s.jsx)(n.strong,{children:"Parameter Drilling"}),".\nIf you have a document hierarchy like ",(0,s.jsx)(n.code,{children:"Book > Chapter > Section > Component"}),', and the Component needs to know the "Primary Color" or the "Current Theme," you traditionally have to pass that variable manually through every single function call.']}),"\n",(0,s.jsxs)(n.p,{children:["Loom solves this with the ",(0,s.jsx)(n.strong,{children:"Provider Pattern"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"the-problem-brittle-templates",children:"The Problem: Brittle Templates"}),"\n",(0,s.jsx)(n.p,{children:'In standard Typst, your code often looks like this. You are forced to be a "data courier," carrying variables down to places that need them.'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typ",children:"// \u274c The old way: Passing state manually everywhere\n#let my-chapter(number, theme-color, body) = {\n  // You have to accept 'theme-color' just to pass it down...\n  block(body(number, theme-color))\n}\n\n#let my-section(chapter-num, theme-color, body) = {\n  // ...and pass it down again...\n  text(fill: theme-color)[#chapter-num.1]\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:'This is brittle. If you want to add a "font-size" setting later, you have to update every single function signature in the chain.'}),"\n",(0,s.jsx)(n.h2,{id:"the-solution-context-injection",children:"The Solution: Context Injection"}),"\n",(0,s.jsxs)(n.p,{children:["Loom components (Motifs) have a built-in mechanism called ",(0,s.jsx)(n.strong,{children:"Scope"}),". It works remarkably like ",(0,s.jsx)(n.strong,{children:"CSS variables"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Any component can act as a ",(0,s.jsx)(n.strong,{children:"Provider"}),", injecting data into a shared context (",(0,s.jsx)(n.code,{children:"ctx"}),') that automatically "cascades" down to all descendants. The descendants act as ',(0,s.jsx)(n.strong,{children:"Consumers"}),", reading from that context without knowing who provided it."]}),"\n",(0,s.jsx)(n.h3,{id:"implementing-a-smart-component",children:'Implementing a "Smart" Component'}),"\n",(0,s.jsx)(n.p,{children:"The most robust way to use Scope is to handle three cases at once:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Override:"})," The user specifically passed a value (",(0,s.jsx)(n.code,{children:"color: red"}),")."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Inherit:"})," The user passed ",(0,s.jsx)(n.code,{children:"auto"}),", so we look up the tree."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Default:"})," No one defined it, so we fallback to a safe value (",(0,s.jsx)(n.code,{children:"black"}),")."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Loom makes this easy with ",(0,s.jsx)(n.code,{children:"loom.core.scope"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typ",children:"#import \"@preview/loom:0.1.0\": *\n#let (motif, weave, ..) = construct-loom(<my-lib>)\n\n// THE COMPONENT\n#let my-button(label, color: auto) = motif(\n  // 1. THE SCOPE PHASE (Logic)\n  // We determine the final value BEFORE we draw.\n  // The syntax is: key: (override_value, fallback_default)\n  scope: (ctx) => core.scope(ctx,\n    my-btn-color: (color, black)\n  ),\n\n  // 2. THE DRAW PHASE (Render)\n  // We can now safely assume 'ctx.my-btn-color' exists.\n  draw: (ctx, public, view, body) => {\n    box(fill: ctx.my-btn-color, inset: 10pt)[#label]\n  },\n  none\n)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"using-the-component",children:"Using the Component"}),"\n",(0,s.jsx)(n.p,{children:"Because we implemented the Provider pattern, this single component is now incredibly flexible:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typ",children:'// Case 1: Explicit Override\n#my-button("Danger", color: red)\n\n// Case 2: Context Inheritance (The Provider)\n// We set the color ONCE at the top...\n#motif(scope: ctx => core.scope(ctx, my-btn-color: (blue, none)))[\n  #stack(dir: ltr)[\n    #my-button("Submit")  // ...and these automatically become Blue\n    #my-button("Cancel")  // ...without passing arguments!\n  ]\n]\n\n// Case 3: Robust Default\n#my-button("Boring") // Defaults to Black, doesn\'t crash.\n'})}),"\n",(0,s.jsx)(n.h2,{id:"critical-concepts",children:"Critical Concepts"}),"\n",(0,s.jsx)(n.p,{children:"To use this pattern effectively, you must understand two specific rules about Loom's data flow."}),"\n",(0,s.jsx)(n.h3,{id:"1-scope-is-public-self--children",children:'1. Scope is "Public" (Self + Children)'}),"\n",(0,s.jsxs)(n.p,{children:["When you use the ",(0,s.jsx)(n.code,{children:"scope"})," function, the changes you make to ",(0,s.jsx)(n.code,{children:"ctx"})," are visible to:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"The Component Itself:"})," You can access the new values immediately in your ",(0,s.jsx)(n.code,{children:"draw"})," or ",(0,s.jsx)(n.code,{children:"measure"})," functions."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"All Descendants:"})," Every child, grandchild, and great-grandchild will see these values."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This is why we say it behaves like CSS. If you set a property, it propagates down until something else overrides it."}),"\n",(0,s.jsx)(n.h3,{id:"2-measure-is-private-local-only",children:'2. Measure is "Private" (Local Only)'}),"\n",(0,s.jsxs)(n.p,{children:["In contrast, if you calculate something inside the ",(0,s.jsx)(n.code,{children:"measure"})," function and return it as part of the ",(0,s.jsx)(n.code,{children:"view"})," tuple, that data is ",(0,s.jsx)(n.strong,{children:"private"}),"."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["It is visible to your ",(0,s.jsx)(n.code,{children:"draw"})," function."]}),"\n",(0,s.jsxs)(n.li,{children:["It is ",(0,s.jsx)(n.strong,{children:"NOT"})," passed down to children."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Rule of Thumb:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"scope"})," for ",(0,s.jsx)(n.strong,{children:"Shared State"})," (Themes, Config, Chapter Numbers)."]}),"\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"measure"})," for ",(0,s.jsx)(n.strong,{children:"Local Logic"})," (Geometry, layout calculations)."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"always-sanitize-with-scope",children:"Always Sanitize with Scope"}),"\n",(0,s.jsxs)(n.p,{children:['A common mistake is assuming a key exists because "usually a parent sets it."\nIf a user pastes your component into an empty file, ',(0,s.jsx)(n.code,{children:"ctx.my-key"})," might be missing, causing a crash."]}),"\n",(0,s.jsxs)(n.p,{children:["By using the ",(0,s.jsx)(n.code,{children:"scope: (ctx) => core.scope(ctx, key: (auto, default))"})," pattern shown above, you guarantee that the key ",(0,s.jsx)(n.strong,{children:"always exists"})," with at least a default value, making your components crash-proof."]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453(e,n,t){t.d(n,{R:()=>r,x:()=>l});var o=t(6540);const s={},i=o.createContext(s);function r(e){const n=o.useContext(i);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);