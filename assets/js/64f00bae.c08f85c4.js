"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[563],{2147(e,s,n){n.r(s),n.d(s,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"advanced/performance","title":"Performance & Optimization","description":"Understanding the Cost of Reactivity","source":"@site/docs/advanced/performance.md","sourceDirName":"advanced","slug":"/advanced/performance","permalink":"/loom/advanced/performance","draft":false,"unlisted":false,"editUrl":"https://github.com/leonieziechmann/loom/tree/main/docs/advanced/performance.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Advanced Guides","permalink":"/loom/category/advanced-guides"},"next":{"title":"Limitations & Constraints","permalink":"/loom/advanced/limitations"}}');var i=n(4848),l=n(8453);const r={sidebar_position:1},o="Performance & Optimization",d={},c=[{value:"Real-World Benchmarks",id:"real-world-benchmarks",level:2},{value:"The Cost Model",id:"the-cost-model",level:2},{value:"1. The Multi-Pass Multiplier",id:"1-the-multi-pass-multiplier",level:3},{value:"2. Context Mutation Overhead",id:"2-context-mutation-overhead",level:3},{value:"3. Recursion Limits (The Stack)",id:"3-recursion-limits-the-stack",level:3},{value:"Optimization Strategies",id:"optimization-strategies",level:2},{value:"1. Use <code>data-motif</code> for Logic",id:"1-use-data-motif-for-logic",level:3},{value:"2. Filter Early",id:"2-filter-early",level:3},{value:"3. Memoize Heavy Calculations",id:"3-memoize-heavy-calculations",level:3},{value:"4. Stabilize Quickly (Convergence)",id:"4-stabilize-quickly-convergence",level:3}];function a(e){const s={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"performance--optimization",children:"Performance & Optimization"})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Understanding the Cost of Reactivity"})}),"\n",(0,i.jsx)(s.p,{children:'Loom brings powerful capabilities to Typst, but "Time Travel" comes at a cost. Because Loom runs your document logic multiple times to resolve dependencies, it will always be slower than a standard, linear Typst document.'}),"\n",(0,i.jsx)(s.p,{children:"This guide explains where that time goes and how to keep your documents fast."}),"\n",(0,i.jsx)(s.h2,{id:"real-world-benchmarks",children:"Real-World Benchmarks"}),"\n",(0,i.jsx)(s.p,{children:"To give you a realistic idea of Loom's overhead, here are compilation times from our test suite (running on standard hardware):"}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{style:{textAlign:"left"},children:"Scenario"}),(0,i.jsx)(s.th,{style:{textAlign:"left"},children:"Complexity"}),(0,i.jsx)(s.th,{style:{textAlign:"left"},children:"Time"}),(0,i.jsx)(s.th,{style:{textAlign:"left"},children:"Verdict"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{style:{textAlign:"left"},children:(0,i.jsx)(s.strong,{children:"External Wrappers"})}),(0,i.jsxs)(s.td,{style:{textAlign:"left"},children:["Shallow nesting, wrapping ",(0,i.jsx)(s.code,{children:"cetz"})," or ",(0,i.jsx)(s.code,{children:"codly"}),"."]}),(0,i.jsx)(s.td,{style:{textAlign:"left"},children:(0,i.jsx)(s.strong,{children:"~2.3ms"})}),(0,i.jsxs)(s.td,{style:{textAlign:"left"},children:["\u26a1 ",(0,i.jsx)(s.strong,{children:"Negligible"})]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{style:{textAlign:"left"},children:(0,i.jsx)(s.strong,{children:"Standard Logic"})}),(0,i.jsx)(s.td,{style:{textAlign:"left"},children:"Unit tests for signals, scope, and motifs."}),(0,i.jsx)(s.td,{style:{textAlign:"left"},children:(0,i.jsx)(s.strong,{children:"~14.5ms"})}),(0,i.jsxs)(s.td,{style:{textAlign:"left"},children:["\u26a1 ",(0,i.jsx)(s.strong,{children:"Negligible"})]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{style:{textAlign:"left"},children:(0,i.jsx)(s.strong,{children:"Recipe Showcase"})}),(0,i.jsx)(s.td,{style:{textAlign:"left"},children:"Real-world document, ~20 data nodes, 2 passes."}),(0,i.jsx)(s.td,{style:{textAlign:"left"},children:(0,i.jsx)(s.strong,{children:"~16ms"})}),(0,i.jsxs)(s.td,{style:{textAlign:"left"},children:["\ud83d\ude80 ",(0,i.jsx)(s.strong,{children:"Fast"})]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{style:{textAlign:"left"},children:(0,i.jsx)(s.strong,{children:"Stress Test (AST)"})}),(0,i.jsx)(s.td,{style:{textAlign:"left"},children:"Deep recursion (50 levels), complex layouts."}),(0,i.jsx)(s.td,{style:{textAlign:"left"},children:(0,i.jsx)(s.strong,{children:"~94ms"})}),(0,i.jsxs)(s.td,{style:{textAlign:"left"},children:["\ud83d\udfe2 ",(0,i.jsx)(s.strong,{children:"Perceptible"})]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{style:{textAlign:"left"},children:(0,i.jsx)(s.strong,{children:'"The Legion"'})}),(0,i.jsxs)(s.td,{style:{textAlign:"left"},children:[(0,i.jsx)(s.strong,{children:"2,000+"})," nodes, 500+ context mutations."]}),(0,i.jsx)(s.td,{style:{textAlign:"left"},children:(0,i.jsx)(s.strong,{children:"~7.8s"})}),(0,i.jsxs)(s.td,{style:{textAlign:"left"},children:["\ud83d\udd34 ",(0,i.jsx)(s.strong,{children:"Heavy"})]})]})]})]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Takeaway:"})," For normal documents (Reports, Invoices, Dashboards), Loom adds milliseconds, not seconds. Performance only degrades when you treat Typst like a database engine (processing thousands of items)."]}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"the-cost-model",children:"The Cost Model"}),"\n",(0,i.jsx)(s.p,{children:"The compilation time of a Loom document can be roughly estimated as:"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Time \u2248 (Node Count + Context Complexity) \xd7 (Passes)"})}),"\n",(0,i.jsx)(s.h3,{id:"1-the-multi-pass-multiplier",children:"1. The Multi-Pass Multiplier"}),"\n",(0,i.jsxs)(s.p,{children:["Loom runs the ",(0,i.jsx)(s.code,{children:"measure"})," phase in a loop."]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Default:"})," 2 Passes (1 Measure + 1 Draw). Cost: ~2x standard Typst."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Complex:"})," If you set ",(0,i.jsx)(s.code,{children:"max-passes: 5"}),", your document compiles ~5x slower."]}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Tip:"})," Keep ",(0,i.jsx)(s.code,{children:"max-passes"})," as low as possible. Most documents only need 2 or 3 passes. Only increase it if you have deep dependency chains (e.g., A needs B, which needs C, which needs D)."]}),"\n",(0,i.jsx)(s.h3,{id:"2-context-mutation-overhead",children:"2. Context Mutation Overhead"}),"\n",(0,i.jsxs)(s.p,{children:["Typst dictionaries are ",(0,i.jsx)(s.strong,{children:"immutable"}),". Every time you use ",(0,i.jsx)(s.code,{children:"scope"})," to inject a variable (e.g., ",(0,i.jsx)(s.code,{children:'ctx + (theme: "dark")'}),"), the engine must create a ",(0,i.jsx)(s.em,{children:"copy"})," of the context dictionary."]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Cheap:"})," Reading values (",(0,i.jsx)(s.code,{children:'ctx.at("key")'}),")."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Expensive:"})," Writing values deeply nested in the tree for every single child."]}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Benchmark:"}),' In our "Legion" stress test, processing 500 sequential context mutations was the primary driver of the 7.8s runtime.']}),"\n",(0,i.jsx)(s.h3,{id:"3-recursion-limits-the-stack",children:"3. Recursion Limits (The Stack)"}),"\n",(0,i.jsxs)(s.p,{children:["Loom's ",(0,i.jsx)(s.code,{children:"intertwine"})," engine is recursive. Typst has a fixed stack size."]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Limit:"})," Approximately ",(0,i.jsx)(s.strong,{children:"50-60 levels"})," of nesting."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Result:"})," If you nest components too deeply (e.g., ",(0,i.jsx)(s.code,{children:"div > div > ... > div"}),'), the compiler will panic with a "stack overflow".']}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Best Practice:"})," Flatten your structure where possible. Loom is designed for document architecture (Sections, Components), not for rendering fractals or pixel-level grids."]}),"\n",(0,i.jsx)(s.h2,{id:"optimization-strategies",children:"Optimization Strategies"}),"\n",(0,i.jsxs)(s.h3,{id:"1-use-data-motif-for-logic",children:["1. Use ",(0,i.jsx)(s.code,{children:"data-motif"})," for Logic"]}),"\n",(0,i.jsxs)(s.p,{children:["If a component exists only to calculate data (like an ",(0,i.jsx)(s.code,{children:"ingredient"})," or a ",(0,i.jsx)(s.code,{children:"metadata"})," tag), always use ",(0,i.jsx)(s.code,{children:"data-motif"}),"."]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["It has no ",(0,i.jsx)(s.code,{children:"draw"})," phase (returns ",(0,i.jsx)(s.code,{children:"none"})," immediately), saving layout time in the final pass."]}),"\n",(0,i.jsxs)(s.li,{children:["It avoids processing a ",(0,i.jsx)(s.code,{children:"body"})," content block."]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"2-filter-early",children:"2. Filter Early"}),"\n",(0,i.jsxs)(s.p,{children:["In your ",(0,i.jsx)(s.code,{children:"measure"})," function, use ",(0,i.jsx)(s.code,{children:"query.select"})," or ",(0,i.jsx)(s.code,{children:"query.find"})," to narrow down the children you process. Avoid mapping over ",(0,i.jsx)(s.em,{children:"all"})," ",(0,i.jsx)(s.code,{children:"children"}),' if you only need the "tasks".']}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typ",children:'// \u2705 Fast: Only look at relevant signals\nlet tasks = query.select(children, "task")\n\n// \u26a0\ufe0f Slower: Iterating everything unnecessarily\nlet everything = children.map(c => process-heavy-logic(c))\n\n'})}),"\n",(0,i.jsx)(s.h3,{id:"3-memoize-heavy-calculations",children:"3. Memoize Heavy Calculations"}),"\n",(0,i.jsxs)(s.p,{children:["If you have a heavy function (e.g., generating a complex chart), try to ensure it only runs in the ",(0,i.jsx)(s.strong,{children:"Final Draw Pass"}),", not during the Measure passes."]}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"measure"})," phase should only calculate ",(0,i.jsx)(s.em,{children:"metadata"})," (sizes, prices, counts). Leave the heavy pixel-pushing for ",(0,i.jsx)(s.code,{children:"draw"}),"."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typ",children:"// \u2705 Good Separation\nmeasure: (ctx, _) => ( (price: 10), (price: 10) ), // Fast signal\ndraw: (ctx, _, view, _) => {\n  // Expensive chart generation happens ONCE here\n  cetz.canvas(...)\n}\n"})}),"\n",(0,i.jsx)(s.h3,{id:"4-stabilize-quickly-convergence",children:"4. Stabilize Quickly (Convergence)"}),"\n",(0,i.jsx)(s.p,{children:"Ensure your signals stabilize as fast as possible."}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Bad:"})," A signal that toggles between ",(0,i.jsx)(s.code,{children:"true"})," and ",(0,i.jsx)(s.code,{children:"false"})," every pass. This forces Loom to run until ",(0,i.jsx)(s.code,{children:"max-passes"})," is hit."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Good:"})," A signal that settles on a value in Pass 2 and stays there."]}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,l.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},8453(e,s,n){n.d(s,{R:()=>r,x:()=>o});var t=n(6540);const i={},l=t.createContext(i);function r(e){const s=t.useContext(l);return t.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(l.Provider,{value:s},e.children)}}}]);