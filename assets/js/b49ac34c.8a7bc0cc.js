"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[950],{8025(e,n,t){t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"api-reference/mutator","title":"Mutator API","description":"Immutable State Updates","source":"@site/docs/api-reference/mutator.md","sourceDirName":"api-reference","slug":"/api-reference/mutator","permalink":"/loom/api-reference/mutator","draft":false,"unlisted":false,"editUrl":"https://github.com/leonieziechmann/loom/tree/main/docs/api-reference/mutator.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Motifs API","permalink":"/loom/api-reference/motifs"},"next":{"title":"Contributing to Loom","permalink":"/loom/contributing"}}');var r=t(4848),i=t(8453);const a={sidebar_position:5},c="Mutator API",o={},d=[{value:"The Batch Transaction",id:"the-batch-transaction",level:2},{value:"Example",id:"example",level:3},{value:"Operations",id:"operations",level:2},{value:"<code>put</code>",id:"put",level:3},{value:"<code>ensure</code>",id:"ensure",level:3},{value:"<code>update</code>",id:"update",level:3},{value:"<code>remove</code>",id:"remove",level:3},{value:"<code>merge</code>",id:"merge",level:3},{value:"Nested Updates",id:"nested-updates",level:2},{value:"<code>nest</code>",id:"nest",level:3}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"mutator-api",children:"Mutator API"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Immutable State Updates"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"mutator"}),' module provides a functional, transaction-based API for modifying Typst dictionaries. Because Typst data structures are immutable, "modifying" a dictionary actually means creating a new copy with changes applied.']}),"\n",(0,r.jsxs)(n.p,{children:["This module makes complex, nested updates clean and readable, avoiding deep nesting of ",(0,r.jsx)(n.code,{children:"dict.insert"})," or ",(0,r.jsx)(n.code,{children:"+"})," operators."]}),"\n",(0,r.jsx)(n.h2,{id:"the-batch-transaction",children:"The Batch Transaction"}),"\n",(0,r.jsxs)(n.p,{children:["The core concept is the ",(0,r.jsx)(n.code,{children:"batch"})," function, which applies a sequence of operations to a target dictionary."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typ",children:"loom.mutator.batch(target, ops) -> dictionary\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"target"})})," (",(0,r.jsx)(n.code,{children:"dictionary"})," | ",(0,r.jsx)(n.code,{children:"none"}),"): The starting state. If ",(0,r.jsx)(n.code,{children:"none"}),", starts with ",(0,r.jsx)(n.code,{children:"(:)"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"ops"})})," (",(0,r.jsx)(n.code,{children:"array<function>"}),"): A list of operations (created by ",(0,r.jsx)(n.code,{children:"put"}),", ",(0,r.jsx)(n.code,{children:"update"}),", etc.) to apply sequentially."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typ",children:'#import "@preview/loom:0.1.0": mutator\n\n#let state = (count: 0, user: "Guest")\n\n#let new-state = mutator.batch(state, {\n  import mutator: *\n\n  put("user", "Admin")\n  update("count", c => c + 1)\n  put("status", "active")\n})\n\n// Result: (count: 1, user: "Admin", status: "active")\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"operations",children:"Operations"}),"\n",(0,r.jsxs)(n.p,{children:["These functions return ",(0,r.jsx)(n.strong,{children:"Operation Objects"})," (functions) that are passed to ",(0,r.jsx)(n.code,{children:"batch"}),". They are not meant to be called on their own."]}),"\n",(0,r.jsx)(n.h3,{id:"put",children:(0,r.jsx)(n.code,{children:"put"})}),"\n",(0,r.jsx)(n.p,{children:"Sets a key to a specific value. Overwrites the value if the key already exists."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typ",children:"put(key, value)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"ensure",children:(0,r.jsx)(n.code,{children:"ensure"})}),"\n",(0,r.jsxs)(n.p,{children:["Sets a value ",(0,r.jsx)(n.strong,{children:"only if the key is missing"})," (or ",(0,r.jsx)(n.code,{children:"none"}),"). Useful for safely setting defaults without overwriting existing data."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typ",children:"ensure(key, default-value)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"update",children:(0,r.jsx)(n.code,{children:"update"})}),"\n",(0,r.jsx)(n.p,{children:"Transforms an existing value using a callback function."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typ",children:"update(key, callback)\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"callback"})}),": ",(0,r.jsx)(n.code,{children:"(current-value) => new-value"})]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"remove",children:(0,r.jsx)(n.code,{children:"remove"})}),"\n",(0,r.jsx)(n.p,{children:"Deletes a key from the dictionary."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typ",children:"remove(key)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"merge",children:(0,r.jsx)(n.code,{children:"merge"})}),"\n",(0,r.jsx)(n.p,{children:"Merges another dictionary into the current state (shallow merge)."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typ",children:"merge(other-dictionary)\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"nested-updates",children:"Nested Updates"}),"\n",(0,r.jsx)(n.h3,{id:"nest",children:(0,r.jsx)(n.code,{children:"nest"})}),"\n",(0,r.jsx)(n.p,{children:"Applies a batch of operations to a sub-dictionary.\nIf the key does not exist (or is not a dictionary), it initializes an empty dictionary at that location first."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typ",children:"nest(key, sub-ops)\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"sub-ops"})}),": An array of operations to apply to the child dictionary."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example: Deeply Nested Config"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typ",children:'#let config = (theme: (dark: false))\n\n#let new-config = mutator.batch(config, {\n  import mutator: *\n\n  // Update existing nested key\n  nest("theme", {\n    put("dark", true)\n    put("accent", blue)\n  })\n\n  // Create new nested section\n  nest("meta", {\n    put("author", "Me")\n  })\n})\n\n// Result:\n// (\n//   theme: (dark: true, accent: blue),\n//   meta: (author: "Me")\n// )\n'})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453(e,n,t){t.d(n,{R:()=>a,x:()=>c});var s=t(6540);const r={},i=s.createContext(r);function a(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);